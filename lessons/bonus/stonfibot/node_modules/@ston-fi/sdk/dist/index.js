var X = Object.defineProperty;
var z = (o, s, t) => s in o ? X(o, s, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[s] = t;
var i = (o, s, t) => (z(o, typeof s != "symbol" ? s + "" : s, t), t);
import l from "tonweb";
const h = {
  ADD_LIQUIDITY: 1935855772,
  SWAP: 630424929,
  PROVIDE_LIQUIDITY: 4244235663,
  DIRECT_ADD_LIQUIDITY: 1291331587,
  REFUND: 200537159,
  RESET_GAS: 1117846339,
  COLLECT_FEES: 533429565,
  REQUEST_BURN: 1499400124
}, b = {
  V1: "V1"
}, Ct = {
  [b.V1]: "EQB3ncyBUTjZUA5EnFKR5_EnOMI9V1tTEAAPaiU71gc4TiUt"
}, { Address: H } = l, W = (o, s, t) => {
  let e = BigInt(0);
  for (let n = 0; n < t; n++)
    e *= BigInt(2), e += BigInt(o.get(s + n));
  return e;
}, u = (o) => {
  try {
    let s = W(o.bits, 3, 8);
    s > BigInt(127) && (s = s - BigInt(256));
    const t = W(o.bits, 3 + 8, 256);
    if (s.toString(10) + ":" + t.toString(16) == "0:0")
      return null;
    const e = s.toString(10) + ":" + t.toString(16).padStart(64, "0");
    return new H(e);
  } catch {
    return null;
  }
}, {
  boc: { Cell: k },
  utils: { BN: f }
} = l;
class K {
  constructor() {
    i(this, "createRefundBody", async (s, t) => {
      const e = new k();
      return e.bits.writeUint(h.REFUND, 32), e.bits.writeUint((t == null ? void 0 : t.queryId) ?? 0, 64), e;
    });
    i(this, "createDirectAddLiquidityBody", async (s, t) => {
      const e = new k();
      return e.bits.writeUint(h.DIRECT_ADD_LIQUIDITY, 32), e.bits.writeUint(t.queryId ?? 0, 64), e.bits.writeCoins(new f(t.amount0)), e.bits.writeCoins(new f(t.amount1)), e.bits.writeCoins(new f(t.minimumLpToMint ?? 1)), e;
    });
    i(this, "createResetGasBody", async (s, t) => {
      const e = new k();
      return e.bits.writeUint(h.RESET_GAS, 32), e.bits.writeUint((t == null ? void 0 : t.queryId) ?? 0, 64), e;
    });
    i(this, "getData", async (s) => {
      const t = await s.getAddress(), e = await s.provider.call2(
        t.toString(),
        "get_lp_account_data"
      );
      return {
        userAddress: u(e[0]),
        poolAddress: u(e[1]),
        amount0: e[2],
        amount1: e[3]
      };
    });
  }
  get gasConstants() {
    return {
      refund: new f(5e8),
      directAddLp: new f(3e8),
      resetGas: new f(3e8)
    };
  }
}
const {
  Contract: tt,
  utils: { BN: R }
} = l, q = {
  [b.V1]: K
};
class et extends tt {
  constructor(t, { revision: e, ...n }) {
    super(t, n);
    i(this, "revision");
    if (typeof e == "string") {
      if (!q[e])
        throw Error(`Unknown account revision: ${e}`);
      this.revision = new q[e]();
    } else
      this.revision = e;
  }
  get gasConstants() {
    return this.revision.gasConstants;
  }
  /**
   * Create a payload for the `refund_me` transaction.
   *
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `refund_me` transaction.
   */
  async createRefundBody(t) {
    return this.revision.createRefundBody(this, t);
  }
  /**
   * Create a payload for the `direct_add_liquidity` transaction.
   *
   * @param {BN | number} params.amount0 - Amount of the first Jetton tokens (in basic token units)
   * @param {BN | number} params.amount1 - Amount of the second Jetton tokens (in basic token units)
   * @param {BN | number | undefined} params.minimumLpToMint - Optional; minimum amount of received liquidity tokens (in basic token units)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `direct_add_liquidity` transaction.
   */
  async createDirectAddLiquidityBody(t) {
    return this.revision.createDirectAddLiquidityBody(this, t);
  }
  /**
   * Create a payload for the `reset_gas` transaction.
   *
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `reset_gas` transaction.
   */
  async createResetGasBody(t) {
    return this.revision.createResetGasBody(this, t);
  }
  /**
   * @returns {LpAccountData} structure containing current state of the lp account.
   */
  async getData() {
    return await this.revision.getData(this);
  }
  /**
   * Build all data required to execute a `refund_me` transaction.
   *
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `refund_me` transaction.
   */
  async buildRefundTxParams(t) {
    const e = await this.getAddress(), n = await this.createRefundBody({ queryId: t == null ? void 0 : t.queryId }), r = new R((t == null ? void 0 : t.gasAmount) ?? this.gasConstants.refund);
    return { to: e, payload: n, gasAmount: r };
  }
  /**
   * Build all data required to execute a `direct_add_liquidity` transaction.
   *
   * @param {BN | number} params.amount0 - Amount of the first Jetton tokens (in basic token units)
   * @param {BN | number} params.amount1 - Amount of the second Jetton tokens (in basic token units)
   * @param {BN | number | undefined} params.minimumLpToMint - Optional; minimum amount of received liquidity tokens (in basic token units)
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `direct_add_liquidity` transaction.
   */
  async buildDirectAddLiquidityTxParams(t) {
    const e = await this.getAddress(), n = await this.createDirectAddLiquidityBody({
      amount0: t.amount0,
      amount1: t.amount1,
      minimumLpToMint: t.minimumLpToMint,
      queryId: t.queryId
    }), r = new R(t.gasAmount ?? this.gasConstants.directAddLp);
    return { to: e, payload: n, gasAmount: r };
  }
  /**
   * Build all data required to execute a `reset_gas` transaction.
   *
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `reset_gas` transaction.
   */
  async buildResetGasTxParams(t) {
    const e = await this.getAddress(), n = await this.createResetGasBody({ queryId: t == null ? void 0 : t.queryId }), r = new R((t == null ? void 0 : t.gasAmount) ?? this.gasConstants.resetGas);
    return { to: e, payload: n, gasAmount: r };
  }
}
const {
  utils: { BN: _, bytesToBase64: L },
  boc: { Cell: T },
  Address: D
} = l;
class Y {
  constructor() {
    i(this, "createCollectFeesBody", async (s, t) => {
      const e = new T();
      return e.bits.writeUint(h.COLLECT_FEES, 32), e.bits.writeUint((t == null ? void 0 : t.queryId) ?? 0, 64), e;
    });
    i(this, "createBurnBody", async (s, t) => {
      const e = new T();
      return e.bits.writeUint(h.REQUEST_BURN, 32), e.bits.writeUint(t.queryId ?? 0, 64), e.bits.writeCoins(new _(t.amount)), e.bits.writeAddress(new D(t.responseAddress)), e;
    });
    i(this, "getExpectedOutputs", async (s, t) => {
      const e = new T();
      e.bits.writeAddress(new D(t.jettonWallet));
      const n = L(await e.toBoc(!1)), r = await s.getAddress(), d = await s.provider.call2(
        r.toString(),
        "get_expected_outputs",
        [
          ["int", t.amount.toString()],
          ["tvm.Slice", n]
        ]
      );
      return {
        jettonToReceive: d[0],
        protocolFeePaid: d[1],
        refFeePaid: d[2]
      };
    });
    i(this, "getExpectedTokens", async (s, t) => {
      const e = await s.getAddress();
      return await s.provider.call2(
        e.toString(),
        "get_expected_tokens",
        [
          ["int", t.amount0.toString()],
          ["int", t.amount1.toString()]
        ]
      );
    });
    i(this, "getExpectedLiquidity", async (s, t) => {
      const e = await s.getAddress(), n = await s.provider.call2(
        e.toString(),
        "get_expected_liquidity",
        [["int", t.jettonAmount.toString()]]
      );
      return {
        amount0: n[0],
        amount1: n[1]
      };
    });
    i(this, "getLpAccountAddress", async (s, t) => {
      const e = new T();
      e.bits.writeAddress(new D(t.ownerAddress));
      const n = L(await e.toBoc(!1)), r = await s.getAddress(), d = await s.provider.call2(
        r.toString(),
        "get_lp_account_address",
        [["tvm.Slice", n]]
      );
      return u(d);
    });
    i(this, "constructLpAccountRevision", (s) => new K());
    i(this, "getData", async (s) => {
      const t = await s.getAddress(), e = await s.provider.call2(
        t.toString(),
        "get_pool_data"
      );
      return {
        reserve0: e[0],
        reserve1: e[1],
        token0WalletAddress: u(e[2]),
        token1WalletAddress: u(e[3]),
        lpFee: e[4],
        protocolFee: e[5],
        refFee: e[6],
        protocolFeeAddress: u(e[7]),
        collectedToken0ProtocolFee: e[8],
        collectedToken1ProtocolFee: e[9]
      };
    });
  }
  get gasConstants() {
    return {
      collectFees: new _(11e8),
      burn: new _(5e8)
    };
  }
}
const {
  Address: N,
  utils: { BN: F },
  token: {
    jetton: { JettonMinter: st, JettonWallet: nt }
  }
} = l, x = {
  [b.V1]: Y
};
class ot extends st {
  constructor(t, { revision: e, ...n }) {
    super(t, n);
    i(this, "revision");
    if (typeof e == "string") {
      if (!x[e])
        throw Error(`Unknown pool revision: ${e}`);
      this.revision = new x[e]();
    } else
      this.revision = e;
  }
  get gasConstants() {
    return this.revision.gasConstants;
  }
  /**
   * Create a payload for the `collect_fees` transaction.
   *
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `collect_fees` transaction.
   */
  async createCollectFeesBody(t) {
    return this.revision.createCollectFeesBody(this, t);
  }
  /**
   * Create a payload for the `burn` transaction.
   *
   * @param {BN | number} params.amount - Amount of lp tokens to burn (in basic token units)
   * @param {Address | string} params.responseAddress - Address of a user
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `burn` transaction.
   */
  async createBurnBody(t) {
    return this.revision.createBurnBody(this, t);
  }
  /**
   * Estimate expected result of the amount of jettonWallet tokens swapped to the other type of tokens of the pool
   *
   * @param {BN | number} params.amount - Amount of tokens to swap (in basic token units)
   * @param {Address | string} params.jettonWallet - Token Jetton address (must be equal to one of the Jetton addresses of the pool)
   *
   * @returns {ExpectedOutputsData} structure with expected result of a token swap
   */
  async getExpectedOutputs(t) {
    return this.revision.getExpectedOutputs(this, t);
  }
  /**
   * Estimate an expected amount of lp tokens minted when providing liquidity.
   *
   * @param {BN | number} params.amount0 - Amount of tokens for the first Jetton (in basic token units)
   * @param {BN | number} params.amount1 - Amount of tokens for the second Jetton (in basic token units)
   *
   * @returns {BN} an estimated amount of liquidity tokens to be minted
   */
  async getExpectedTokens(t) {
    return this.revision.getExpectedTokens(this, t);
  }
  /**
   * Estimate expected liquidity freed upon burning liquidity tokens.
   *
   * @param {BN | number} params.jettonAmount - Amount of liquidity tokens (in basic token units)
   *
   * @returns {PoolAmountsData} structure with expected freed liquidity
   */
  async getExpectedLiquidity(t) {
    return this.revision.getExpectedLiquidity(this, t);
  }
  /**
   * @param {Address | string} params.ownerAddress - Address of a user
   *
   * @returns a JettonWallet object for an address returned by getJettonWalletAddress
   */
  async getJettonWallet(t) {
    const e = await this.getJettonWalletAddress(
      new N(t.ownerAddress)
    );
    return new nt(this.provider, { address: e });
  }
  /**
   * @param {Address | string} params.ownerAddress - Address of a user
   *
   * @returns the lp account address of a user
   */
  async getLpAccountAddress(t) {
    return await this.revision.getLpAccountAddress(this, t);
  }
  /**
   * @param {Address | string} params.ownerAddress - Address of a user
   *
   * @returns {LpAccount} object for address returned by getLpAccountAddress
   */
  async getLpAccount(t) {
    const e = await this.getLpAccountAddress(t);
    return e ? new et(this.provider, {
      address: e,
      revision: this.revision.constructLpAccountRevision(this)
    }) : null;
  }
  /**
   * @returns {PoolData} containing current state of the pool
   */
  async getData() {
    return this.revision.getData(this);
  }
  /**
   * Build all data required to execute a `collect_fees` transaction.
   *
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `collect_fees` transaction.
   */
  async buildCollectFeeTxParams(t) {
    const e = await this.getAddress(), n = await this.createCollectFeesBody({
      queryId: t == null ? void 0 : t.queryId
    }), r = new F(
      (t == null ? void 0 : t.gasAmount) ?? this.gasConstants.collectFees
    );
    return { to: e, payload: n, gasAmount: r };
  }
  /**
   * Build all data required to execute a `burn` transaction.
   *
   * @param {BN | number} params.amount - Amount of lp tokens to burn (in basic token units)
   * @param {Address | string} params.responseAddress - Address of a user
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `burn` transaction.
   */
  async buildBurnTxParams(t) {
    const e = await this.getJettonWalletAddress(
      new N(t.responseAddress)
    ), n = await this.createBurnBody({
      amount: t.amount,
      responseAddress: t.responseAddress,
      queryId: t.queryId
    }), r = new F((t == null ? void 0 : t.gasAmount) ?? this.gasConstants.burn);
    return { to: e, payload: n, gasAmount: r };
  }
}
const {
  utils: { BN: J },
  boc: { Cell: rt },
  Address: $
} = l;
function I(o) {
  const s = new rt();
  return s.bits.writeUint(260734629, 32), s.bits.writeUint(o.queryId, 64), s.bits.writeCoins(new J(o.amount)), s.bits.writeAddress(new $(o.destination)), s.bits.writeAddress(
    o.responseDestination ? new $(o.responseDestination) : void 0
  ), o.customPayload ? (s.refs.push(o.customPayload), s.bits.writeBit(!0)) : s.bits.writeBit(!1), s.bits.writeCoins(new J(o.forwardTonAmount)), o.forwardPayload ? (s.refs.push(o.forwardPayload), s.bits.writeBit(!0)) : s.bits.writeBit(!1), s;
}
function C(o) {
  return !o.isZero();
}
const {
  Address: B,
  utils: { BN: v, bytesToBase64: V },
  boc: { Cell: S }
} = l;
class it {
  constructor() {
    i(this, "createSwapBody", async (s, t) => {
      const e = new S();
      return e.bits.writeUint(h.SWAP, 32), e.bits.writeAddress(new B(t.askJettonWalletAddress)), e.bits.writeCoins(new v(t.minAskAmount)), e.bits.writeAddress(new B(t.userWalletAddress)), t.referralAddress ? (e.bits.writeUint(1, 1), e.bits.writeAddress(new B(t.referralAddress))) : e.bits.writeUint(0, 1), e;
    });
    i(this, "createProvideLiquidityBody", async (s, t) => {
      const e = new S();
      return e.bits.writeUint(h.PROVIDE_LIQUIDITY, 32), e.bits.writeAddress(new B(t.routerWalletAddress)), e.bits.writeCoins(new v(t.minLpOut)), e;
    });
    i(this, "getPoolAddress", async (s, t) => {
      const e = new S();
      e.bits.writeAddress(new B(t.token0));
      const n = new S();
      n.bits.writeAddress(new B(t.token1));
      const r = V(await e.toBoc(!1)), d = V(await n.toBoc(!1)), c = await s.getAddress(), a = await s.provider.call2(
        c.toString(),
        "get_pool_address",
        [
          ["tvm.Slice", r],
          ["tvm.Slice", d]
        ]
      );
      return u(a);
    });
    i(this, "getData", async (s) => {
      const t = await s.getAddress(), e = await s.provider.call2(
        t.toString(),
        "get_router_data",
        []
      );
      return {
        isLocked: C(e[0]),
        adminAddress: u(e[1]),
        tempUpgrade: e[2],
        poolCode: e[3],
        jettonLpWalletCode: e[4],
        lpAccountCode: e[5]
      };
    });
    i(this, "constructPoolRevision", (s) => new Y());
  }
  get gasConstants() {
    return {
      swap: new v(3e8),
      provideLp: new v(3e8),
      swapForward: new v(265e6),
      provideLpForward: new v(265e6)
    };
  }
}
const {
  Address: M,
  Contract: dt,
  utils: { BN: A },
  token: {
    jetton: { JettonMinter: w }
  }
} = l, O = {
  [b.V1]: it
};
class Tt extends dt {
  constructor(t, { revision: e, ...n }) {
    super(t, n);
    i(this, "revision");
    if (typeof e == "string") {
      if (!O[e])
        throw Error(`Unknown router revision: ${e}`);
      this.revision = new O[e]();
    } else
      this.revision = e;
  }
  get gasConstants() {
    return this.revision.gasConstants;
  }
  /**
   * Create a payload for the `swap` transaction.
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
   * @param {Address | string} params.askJettonWalletAddress - Jetton router's wallet address of tokens to be received
   * @param {Address | string | undefined} params.referralAddress - Optional; referral address
   *
   * @returns {Cell} payload for the `swap` transaction.
   */
  async createSwapBody(t) {
    return this.revision.createSwapBody(this, t);
  }
  /**
   * Create a payload for the `provide_lp` transaction.
   *
   * @param {Address | string} params.routerWalletAddress - Address of the router's Jetton token wallet
   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)
   *
   * @returns payload for the `provide_lp` transaction.
   */
  async createProvideLiquidityBody(t) {
    return this.revision.createProvideLiquidityBody(this, t);
  }
  /**
   * **Note:** It's necessary to specify addresses of Jetton wallets of the router as the arguments of this method.
   * These addresses can be retrieved with getJettonWalletAddress of the Jetton minter.
   * @param {Address | string} params.token0 - The address of the router's wallet of first Jetton
   * @param {Address | string} params.token1 - The address of the router's wallet of second Jetton
   *
   * @returns {Address | null} an address of a pool for a specified pair of assets.
   */
  async getPoolAddress(t) {
    return this.revision.getPoolAddress(this, t);
  }
  /**
   * @param {[Address | string, Address | string]} params.jettonAddresses - Tuple of Jetton addresses of a pool
   *
   * @returns {Pool} object for a pool with specified Jetton token addresses.
   */
  async getPool(t) {
    const e = new w(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.jettonAddresses[0]
      }
    ), n = new w(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.jettonAddresses[1]
      }
    ), r = await this.getAddress(), d = await e.getJettonWalletAddress(
      r
    ), c = await n.getJettonWalletAddress(
      r
    ), a = await this.getPoolAddress({
      token0: d,
      token1: c
    });
    return a ? new ot(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: a,
        revision: this.revision.constructPoolRevision(this)
      }
    ) : null;
  }
  /**
   * @returns {RouterData} containing current state of the router.
   */
  async getData() {
    return await this.revision.getData(this);
  }
  /**
   * Build all data required to execute a jetton `swap` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped
   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received
   * @param {BN | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)
   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)
   * @param {Address | string | undefined} params.referralAddress - Optional; referral address
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} data required to execute a jetton `swap` transaction
   */
  async buildSwapJettonTxParams(t) {
    const e = new w(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.offerJettonAddress
      }
    ), n = new w(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.askJettonAddress
      }
    ), r = await e.getJettonWalletAddress(
      new M(t.userWalletAddress)
    ), d = await n.getJettonWalletAddress(
      await this.getAddress()
    ), c = await this.createSwapBody({
      userWalletAddress: t.userWalletAddress,
      minAskAmount: t.minAskAmount,
      askJettonWalletAddress: d,
      referralAddress: t.referralAddress
    }), a = new A(
      t.forwardGasAmount ?? this.gasConstants.swapForward
    ), g = I({
      queryId: t.queryId ?? 0,
      amount: t.offerAmount,
      destination: await this.getAddress(),
      forwardTonAmount: a,
      forwardPayload: c
    }), y = new A(t.gasAmount ?? this.gasConstants.swap);
    return {
      to: r,
      payload: g,
      gasAmount: y
    };
  }
  /**
   * Build all data required to execute a ton to jetton `swap` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract
   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received
   * @param {BN | number} params.offerAmount - Amount of ton to be swapped (in nanoTons)
   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)
   * @param {Address | string | undefined} params.referralAddress - Optional; referral address
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} data required to execute a ton to jetton `swap` transaction
   */
  async buildSwapProxyTonTxParams(t) {
    const e = new w(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.proxyTonAddress
      }
    ), n = new w(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.askJettonAddress
      }
    ), r = await e.getJettonWalletAddress(
      await this.getAddress()
    ), d = await n.getJettonWalletAddress(
      await this.getAddress()
    ), c = await this.createSwapBody({
      userWalletAddress: t.userWalletAddress,
      minAskAmount: t.minAskAmount,
      askJettonWalletAddress: d,
      referralAddress: t.referralAddress
    }), a = new A(
      t.forwardGasAmount ?? this.gasConstants.swapForward
    ), g = I({
      queryId: t.queryId ?? 0,
      amount: t.offerAmount,
      destination: await this.getAddress(),
      forwardTonAmount: a,
      forwardPayload: c
    }), y = new A(t.offerAmount).add(a);
    return {
      to: r,
      payload: g,
      gasAmount: y
    };
  }
  /**
   * Collect all data required to execute a jetton `provide_lp` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.sendTokenAddress - Address of the provided Jetton token
   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair
   * @param {BN | number} params.sendAmount - Amount of the first token deposited as liquidity (in basic token units)
   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} data required to execute a jetton `provide_lp` transaction
   */
  async buildProvideLiquidityJettonTxParams(t) {
    const e = new w(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.sendTokenAddress
      }
    ), n = new w(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.otherTokenAddress
      }
    ), r = await e.getJettonWalletAddress(
      new M(t.userWalletAddress)
    ), d = await n.getJettonWalletAddress(
      await this.getAddress()
    ), c = await this.createProvideLiquidityBody({
      routerWalletAddress: d,
      minLpOut: t.minLpOut
    }), a = new A(
      t.forwardGasAmount ?? this.gasConstants.provideLpForward
    ), g = I({
      queryId: t.queryId ?? 0,
      amount: t.sendAmount,
      destination: await this.getAddress(),
      forwardTonAmount: a,
      forwardPayload: c
    }), y = new A(t.gasAmount ?? this.gasConstants.provideLp);
    return {
      to: r,
      payload: g,
      gasAmount: y
    };
  }
  /**
   * Collect all data required to execute a proxy ton `provide_lp` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract
   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair
   * @param {BN | number} params.sendAmount - Amount of ton deposited as liquidity (in nanoTons)
   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)
   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} data required to execute a proxy ton `provide_lp` transaction
   */
  async buildProvideLiquidityProxyTonTxParams(t) {
    const e = new w(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.proxyTonAddress
      }
    ), n = new w(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.otherTokenAddress
      }
    ), r = await e.getJettonWalletAddress(
      await this.getAddress()
    ), d = await n.getJettonWalletAddress(
      await this.getAddress()
    ), c = await this.createProvideLiquidityBody({
      routerWalletAddress: d,
      minLpOut: t.minLpOut
    }), a = new A(
      t.forwardGasAmount ?? this.gasConstants.provideLp
    ), g = I({
      queryId: t.queryId ?? 0,
      amount: t.sendAmount,
      destination: await this.getAddress(),
      forwardTonAmount: a,
      forwardPayload: c
    }), y = new A(t.sendAmount).add(a);
    return {
      to: r,
      payload: g,
      gasAmount: y
    };
  }
}
const U = {
  STAKE: 1858722917,
  CLAIM_REWARDS: 2027548937,
  UNSTAKE: 3106497952
}, Z = {
  V2: "V2"
};
function at(o) {
  return new TextDecoder().decode(o.bits.getTopUppedArray());
}
const {
  utils: { BN: j },
  boc: { Cell: ct }
} = l;
class ut {
  constructor() {
    i(this, "createStakeBody", async (s) => {
      const t = new ct();
      return t.bits.writeUint(U.STAKE, 32), t;
    });
    i(this, "getPendingData", async (s) => {
      const t = await s.getAddress(), e = await s.provider.call2(
        t.toString(),
        "get_pending_data"
      );
      return {
        changeCustodianTs: e[0],
        sendMsgTs: e[1],
        codeUpgradeTs: e[2],
        newCustodian: u(e[3]),
        pendingMsg: e[4],
        newCode: e[5],
        newStorage: e[6]
      };
    });
    i(this, "getVersion", async (s) => {
      const t = await s.getAddress(), e = await s.provider.call2(
        t.toString(),
        "get_version"
      );
      return {
        major: e[0],
        minor: e[1],
        development: at(e[2])
      };
    });
    i(this, "getData", async (s) => {
      const t = await s.getAddress(), e = await s.provider.call2(
        t.toString(),
        "get_farming_minter_data"
      ), n = u(e[14]);
      if (!n)
        throw new Error(
          `Failed to parse stakingTokenWallet from cell: ${e[14]}`
        );
      const r = u(e[15]);
      if (!r)
        throw new Error(
          `Failed to parse rewardTokenWallet from cell: ${e[15]}`
        );
      return {
        nextItemIndex: e[0],
        lastUpdateTime: e[1],
        status: e[2],
        depositedNanorewards: e[3],
        currentStakedTokens: e[4],
        accruedPerUnitNanorewards: e[5],
        claimedFeeNanorewards: e[6],
        accruedFeeNanorewards: e[7],
        accruedNanorewards: e[8],
        claimedNanorewards: e[9],
        contractUniqueId: e[10],
        nanorewardsPer24h: e[11],
        adminFee: e[12],
        minStakeTime: e[13],
        stakingTokenWallet: n,
        rewardTokenWallet: r,
        custodianAddress: u(e[16]),
        canChangeCustodian: C(e[17]),
        canSendRawMsg: C(e[18]),
        canChangeFee: C(e[19]),
        unrestrictedDepositRewards: C(e[20]),
        // NFTs are always soulbound in V2
        soulboundItems: !0
      };
    });
  }
  get gasConstants() {
    return {
      stake: new j(3e8),
      stakeForward: new j(25e7)
    };
  }
}
const {
  Address: lt,
  utils: { BN: G },
  token: {
    nft: { NftCollection: wt },
    jetton: { JettonMinter: At, JettonWallet: gt }
  }
} = l, p = {
  [Z.V2]: ut
};
class St extends wt {
  constructor(t, { revision: e, ...n }) {
    super(t, n);
    i(this, "revision");
    if (typeof e == "string") {
      if (!p[e])
        throw Error(`Unknown pool revision: ${e}`);
      this.revision = new p[e]();
    } else
      this.revision = e;
  }
  get gasConstants() {
    return this.revision.gasConstants;
  }
  /**
   * Create a payload for the `stake` transaction.
   *
   * @returns payload for the `stake` transaction.
   */
  async createStakeBody() {
    return this.revision.createStakeBody(this);
  }
  /**
   * @returns {Address} address of minter for staking jetton
   */
  async getStakingJettonAddress() {
    const { stakingTokenWallet: t } = await this.getData(), e = new gt(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t
      }
    ), { jettonMinterAddress: n } = await e.getData();
    return n;
  }
  async getPendingData() {
    return this.revision.getPendingData(this);
  }
  async getVersion() {
    return this.revision.getVersion(this);
  }
  /**
   * @returns {FarmNftMinterData} containing current state of the minter
   */
  async getData() {
    return this.revision.getData(this);
  }
  /**
   * Build all data required to execute a jetton `stake` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.jettonAddress - Jetton address of token to be staked
   * @param {BN | number} params.jettonAmount - Amount of tokens to be staked (in basic token units)
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} containing all data required to execute a jetton `stake` transaction
   */
  async buildStakeTxParams(t) {
    const n = await new At(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.jettonAddress
      }
    ).getJettonWalletAddress(
      new lt(t.userWalletAddress)
    ), r = await this.createStakeBody(), d = new G(
      t.forwardGasAmount ?? this.gasConstants.stakeForward
    ), c = I({
      queryId: t.queryId ?? 0,
      amount: t.jettonAmount,
      destination: await this.getAddress(),
      responseDestination: t.userWalletAddress,
      forwardTonAmount: d,
      forwardPayload: r
    }), a = new G(t.gasAmount ?? this.gasConstants.stake);
    return {
      to: n,
      payload: c,
      gasAmount: a
    };
  }
}
const {
  boc: { Cell: yt }
} = l;
function ht(o) {
  const s = new yt();
  return s.bits.writeUint(520377210, 32), s.bits.writeUint((o == null ? void 0 : o.queryId) ?? 0, 64), s;
}
const {
  utils: { BN: E },
  boc: { Cell: Q }
} = l;
class ft {
  constructor() {
    i(this, "createClaimRewardsBody", async (s, t) => {
      const e = new Q();
      return e.bits.writeUint(U.CLAIM_REWARDS, 32), e.bits.writeUint((t == null ? void 0 : t.queryId) ?? 0, 64), e;
    });
    i(this, "createUnstakeBody", async (s, t) => {
      const e = new Q();
      return e.bits.writeUint(U.UNSTAKE, 32), e.bits.writeUint((t == null ? void 0 : t.queryId) ?? 0, 64), e;
    });
    i(this, "createDestroyBody", async (s, t) => ht({
      queryId: (t == null ? void 0 : t.queryId) ?? 0
    }));
    i(this, "getFarmingData", async (s) => {
      const t = await s.getAddress(), e = await s.provider.call2(
        t.toString(),
        "get_farming_data"
      );
      return {
        status: e[0],
        revokeTime: e[1],
        stakedTokens: e[2],
        claimedPerUnitNanorewards: e[3],
        stakeDate: e[4],
        // NFTs are always soulbound in V2
        isSoulbound: !0
      };
    });
  }
  get gasConstants() {
    return {
      claimRewards: new E(3e8),
      unstake: new E(4e8),
      destroy: new E(5e7)
    };
  }
}
const {
  utils: { BN: P },
  token: {
    nft: { NftItem: Bt }
  }
} = l, m = {
  [Z.V2]: ft
};
class bt extends Bt {
  constructor(t, { revision: e, ...n }) {
    super(t, n);
    i(this, "revision");
    if (typeof e == "string") {
      if (!m[e])
        throw Error(`Unknown farm NFT item revision: ${e}`);
      this.revision = new m[e]();
    } else
      this.revision = e;
  }
  get gasConstants() {
    return this.revision.gasConstants;
  }
  /**
   * Creates payload for the `claim_rewards` transaction.
   *
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `claim_rewards` transaction.
   */
  async createClaimRewardsBody(t) {
    return this.revision.createClaimRewardsBody(this, t);
  }
  /**
   * Creates payload for the `destroy` transaction.
   *
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `destroy` transaction.
   */
  async createDestroyBody(t) {
    return this.revision.createDestroyBody(this, t);
  }
  /**
   * Creates payload for the `unstake` transaction.
   *
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `unstake` transaction.
   */
  async createUnstakeBody(t) {
    return this.revision.createUnstakeBody(this, t);
  }
  /**
   * @returns {FarmNftItemFarmingData} structure containing current state of the farm NFT
   */
  async getFarmingData() {
    return await this.revision.getFarmingData(this);
  }
  /**
   * Build all data required to execute a `claim_rewards` transaction.
   *
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `claim_rewards` transaction.
   */
  async buildClaimRewardsTxParams(t) {
    const e = await this.getAddress(), n = await this.createClaimRewardsBody({
      queryId: t == null ? void 0 : t.queryId
    }), r = new P(
      (t == null ? void 0 : t.gasAmount) ?? this.gasConstants.claimRewards
    );
    return { to: e, payload: n, gasAmount: r };
  }
  /**
   * Build all data required to execute a `unstake` transaction.
   *
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `unstake` transaction.
   */
  async buildUnstakeTxParams(t) {
    const e = await this.getAddress(), n = await this.createUnstakeBody({ queryId: t == null ? void 0 : t.queryId }), r = new P((t == null ? void 0 : t.gasAmount) ?? this.gasConstants.unstake);
    return { to: e, payload: n, gasAmount: r };
  }
  /**
   * Build all data required to execute a `destroy` transaction.
   *
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `destroy` transaction.
   */
  async buildDestroyTxParams(t) {
    const e = await this.getAddress(), n = await this.createDestroyBody({ queryId: t == null ? void 0 : t.queryId }), r = new P((t == null ? void 0 : t.gasAmount) ?? this.gasConstants.destroy);
    return {
      to: e,
      payload: n,
      gasAmount: r
    };
  }
}
const kt = u;
export {
  h as DEX_OP_CODES,
  U as FARM_OP_CODES,
  Z as FARM_REVISION,
  bt as FarmNftItem,
  ft as FarmNftItemRevisionV2,
  St as FarmNftMinter,
  ut as FarmNftMinterRevisionV2,
  et as LpAccount,
  K as LpAccountRevisionV1,
  ot as Pool,
  Y as PoolRevisionV1,
  b as ROUTER_REVISION,
  Ct as ROUTER_REVISION_ADDRESS,
  Tt as Router,
  it as RouterRevisionV1,
  I as createJettonTransferMessage,
  ht as createSbtDestroyMessage,
  u as parseAddress,
  kt as parseAddressFromCell,
  C as parseBoolean,
  at as parseString
};
//# sourceMappingURL=index.js.map
